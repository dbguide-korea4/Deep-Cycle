import os
import sys
import time
import uuid
from copy import deepcopy
import csv
import json
import pathlib
import importlib

import flask
import boto3
import dash
import dash_core_components as dcc
import dash_html_components as html
import requests
import plotly.graph_objs as go
from dash.dependencies import Input, Output, State
from flask_caching import Cache

drc = importlib.import_module("dash_reusable_components")
utils = importlib.import_module("utils.dash_utils")

DEBUG = True
LOCAL = False
APP_PATH = str(pathlib.Path(__file__).parent.resolve())

server = flask.Flask(__name__)
app = dash.Dash(__name__, server=server)
model = drc.LoadModel()

classes_dic = {1: "glass_bottle", 2: "pet", 3: "can"}


# @server.route('/favicon.ico')
# def favicon():
#     return flask.send_from_directory(os.path.join(server.root_path, 'static'),
#                                      'favicon.ico', mimetype='image/vnd.microsoft.icon')


if "BUCKET_NAME" in os.environ:
    # Change caching to redis if hosted on dds
    cache_config = {
        "CACHE_TYPE": "redis",
        "CACHE_REDIS_URL": os.environ["REDIS_URL"],
        "CACHE_THRESHOLD": 400,
    }
# Local Conditions
else:
    LOCAL = True
    # Caching with filesystem when served locally
    cache_config = {
        "CACHE_TYPE": "filesystem",
        "CACHE_DIR": os.path.join(APP_PATH, "data"),
    }

# S3 Client. It is used to store user images. The bucket name
# is stored inside the utils file, the key is
# the session id generated by uuid

access_key_id = os.environ.get("ACCESS_KEY_ID")
secret_access_key = os.environ.get("SECRET_ACCESS_KEY")
bucket_name = os.environ.get("BUCKET_NAME")

# Empty cache directory before running the app
folder = os.path.join(APP_PATH, "data")
for the_file in os.listdir(folder):
    file_path = os.path.join(folder, the_file)
    try:
        if os.path.isfile(file_path):
            os.unlink(file_path)
    except Exception as e:
        print(e)

# If local, image data is stored locally in image_string.csv
if LOCAL:
    f = open("image_string.csv", "w+")
    f.close()

    # Store images are very long strings, so allowed csv
    # reading length is increased to its maximum allowed value
    maxInt = sys.maxsize
    while True:
        # decrease the maxInt value by factor 10
        # as long as the OverflowError occurs.
        try:
            csv.field_size_limit(maxInt)
            break
        except OverflowError:
            maxInt = int(maxInt / 10)

if not LOCAL:
    s3 = boto3.client(
        "s3",
        endpoint_url="https://storage.googleapis.com",
        aws_access_key_id=access_key_id,
        aws_secret_access_key=secret_access_key,
    )

# Caching
cache = Cache()
cache.init_app(app.server, config=cache_config)


# Store key value value (session_id, stringed_image)
def store_image_string(string_image, key_name):
    if DEBUG:
        print(key_name)
    # If local, the string is stored in image_string.csv
    if LOCAL:
        with open("image_string.csv", mode="w+") as image_file:
            image_writer = csv.DictWriter(
                image_file, fieldnames=["key", "image"])
            image_writer.writeheader()
            image_writer.writerow(dict(key=key_name, image=string_image))
    # Generate the POST attributes
    else:
        post = s3.generate_presigned_post(Bucket=bucket_name, Key=key_name)

        files = {"file": string_image}
        # Post the string file using requests
        requests.post(post["url"], data=post["fields"], files=files)


def serve_layout():
    # Generates a session ID
    session_id = str(uuid.uuid4())

    # Post the image to the right key, inside the bucket named after the
    # session ID
    store_image_string(utils.IMAGE_STRING_PLACEHOLDER, session_id)

    # App Layout
    return html.Div(
        id="root",
        children=[
            # Session ID
            html.Div(session_id, id="session-id"),
            # Main body
            html.Div(
                id="app-container",
                children=[
                    # Banner display
                    html.Div(
                        id="banner",
                        children=[
                            # html.Img(
                            #     id="logo", src=app.get_asset_url("recycle.png")
                            # ),
                            html.H2("Deep cycle", id="title"),
                        ],
                    ),
                    html.Div(
                        id="image",
                        children=[
                            # The Interactive Image Div contains the dcc Graph
                            # showing the image, as well as the hidden div storing
                            # the true image
                            html.Div(
                                id="div-interactive-image",
                                children=[
                                    utils.GRAPH_PLACEHOLDER,
                                    html.Div(
                                        id="div-storage",
                                        children=utils.STORAGE_PLACEHOLDER,

                                    ),
                                ],
                            )
                        ],
                    ),
                ],
            ),
            # Sidebar
            html.Div(
                id="sidebar",
                children=[
                    drc.Card(
                        [
                            dcc.Upload(
                                id="upload-image",
                                children=[
                                    "Drag and Drop or ",
                                    html.A(children="Select an Image"),
                                ],
                                # No CSS alternative here
                                style={
                                    "color": "darkgray",
                                    "width": "100%",
                                    "height": "50px",
                                    "lineHeight": "50px",
                                    "borderWidth": "1px",
                                    "borderStyle": "dashed",
                                    "borderRadius": "5px",
                                    "borderColor": "darkgray",
                                    "textAlign": "center",
                                    "padding": "2rem 0",
                                    "margin-bottom": "2rem",
                                },
                                accept="image/*",
                            ),
                        ]
                    ),
                    html.P(children="Object Count",
                           className='plot-title'),
                    dcc.Graph(
                        id="pie-object-count",
                        style={'height': '40vh', 'width': '100%'}
                    )
                ],
            ),
        ],
    )


app.layout = serve_layout


@app.callback(
    Output("div-interactive-image", "children"),
    [
        Input("upload-image", "contents"),
    ],
    [
        State("interactive-image", "selectedData"),
        State("upload-image", "filename"),
        State("div-storage", "children"),
        State("session-id", "children"),
    ],
)
def update_graph_interactive_image(
        content,
        # new_win_width,
        selectedData,
        new_filename,
        storage,
        session_id,
):
    t_start = time.time()

    # Retrieve information saved in storage, which is a dict containing
    # information about the image and its action stack
    storage = json.loads(storage)
    filename = storage["filename"]  # Filename is the name of the image file.
    image_signature = storage["image_signature"]

    # If a new file was uploaded (new file name changed)
    if new_filename and new_filename != filename:
        # Replace filename
        if DEBUG:
            print(filename, "replaced by", new_filename)
        # Update the storage dict
        storage["filename"] = new_filename

        # Parse the string and convert to pil
        string = content.split(";base64,")[-1]
        im_pil = drc.b64_to_pil(string)

        # Update the image signature, which is the first 200 b64 characters
        # of the string encoding
        storage["image_signature"] = string[:200]

        # Posts the image string into the Bucketeer Storage (which is hosted
        # on S3)
        store_image_string(string, session_id)
        if DEBUG:
            print(new_filename, "added to Bucketeer S3.")

        # Resets the action stack
        storage["action_stack"] = []
        im_pil = model.result_visualize(im_pil)
    else:
        im_pil = drc.new_pil()

    t_end = time.time()
    if DEBUG:
        print(f"Updated Image Storage in {t_end - t_start:.3f} sec")

    return [
        drc.InteractiveImagePIL(
            image_id="interactive-image",
            image=im_pil,
            verbose=DEBUG,
        ),
        html.Div(
            id="div-storage", children=json.dumps(storage), style={"display": "none"}
        ),
    ]


@app.callback(Output("pie-object-count", "figure"),
              [Input("div-storage", "children")])
def update_object_count_pie(content):
    layout = go.Layout(
        showlegend=True,
        plot_bgcolor='darkgray',
        autosize=False,
        margin=go.layout.Margin(
            l=10,
            r=10,
            t=15,
            b=15
        )
    )

    classes = list(classes_dic.values())  # List of each class
    counts = [list(model.result()).count(_)
              for _ in classes_dic.keys()]  # List of each count

    text = [f"{count} detected" for count in counts]

    # Set colorscale to piechart
    colorscale = ['#fa4f56', '#fe6767', '#ff7c79', '#ff908b', '#ffa39d', '#ffb6b0', '#ffc8c3', '#ffdbd7',
                  '#ffedeb', '#ffffff']

    pie = go.Pie(
        labels=classes,
        values=counts,
        text=text,
        hoverinfo="text+percent",
        textinfo="label+percent",
        marker={'colors': colorscale[:len(classes)]}
    )
    return go.Figure(data=[pie], layout=layout)


# Running the server
if __name__ == "__main__":
    app.run_server(debug=DEBUG)
